#labels Phase-Design
#The design of new Google Mock features

This page discusses the design of new Google Mock features.

<wiki:toc max_depth="3" />

= Macros for Defining Actions =

== Problem ==

In Google Mock, defining custom actions requires some non-trivial
effort (thanks to the lack of lambda expressions in C++).  For
example, suppose you want to "increment the value pointed to by the
second argument of the mock function and return it", you could write:

{{{
int IncrementArg1(Unused, int* p, Unused) {
  return ++(*p);
}

... WillOnce(Invoke(IncrementArg1));
}}}

There are several things unsatisfactory about this approach:

  * Even though the action only cares about the second argument of the mock function, its definition needs to list other arguments as dummies.  This is tedious.
  * The defined action is usable only in mock functions that takes exactly 3 arguments - an unnecessary restriction.
  * To use the action, one has to say `Invoke(IncrementArg1)`, which isn't as nice as `IncrementArg1()`.

The latter two problems can be overcome using `MakePolymorphicAction()`,
but it requires much more boilerplate code:

{{{
class IncrementArg1Action {
 public:
  template <typename Result, typename ArgumentTuple>
  Result Perform(const ArgumentTuple& args) const {
    return ++(*tr1::get<1>(args));
  }
};

PolymorphicAction<IncrementArg1Action> IncrementArg1() {
  return MakePolymorphicAction(IncrementArg1Action());
}

... WillOnce(IncrementArg1());
}}}

== Solution ==

We propose to introduce a new macro to make this much simpler.  Using
the syntax:
{{{
ACTION(name) { statements; }
}}}
in a namespace scope will define an action with the given name that
executes the statements.  Inside the statements, you can refer to the
K-th (0-based) argument of the mock function as `argK`.  For example:
{{{
ACTION(IncrementArg1) { return ++(*arg1); }
}}}
allows you to write
{{{
... WillOnce(IncrementArg1());
}}}

Note that you don't need to specify the types of the mock function
arguments, as brevity is a top design goal here.  Rest assured that
your code is still type-safe: you'll get a compiler error if `*arg1`
doesn't support the `++` operator, or if the type of `++(*arg1)` isn't
compatible with the mock function's return type.

Another example:
{{{
ACTION(Foo) {
  (*arg2)(5);
  Blah();
  *arg1 = 0;
  return arg0;
}
}}}
defines an action `Foo()` that invokes argument #2 (a function pointer)
with 5, calls function `Blah()`, sets the value pointed to by argument
#1 to 0, and returns argument #0.

For more convenience and flexibility, you can also use the following
pre-defined symbols in the body of `ACTION`:

|| `argK_Type` || The type of the K-th (0-based) argument of the mock function ||
|| `args` || All arguments of the mock function as a tuple ||
|| `args_Type` || The type of all arguments as a tuple ||
|| `return_Type` || The return type of the mock function ||
|| `function_Type` || The type of the mock function ||

For example, given a mock function whose signature is:
{{{
int DoSomething(bool flag, int* ptr);
}}}
and an `ACTION` definition to be used as a stub action for this mock
function, inside the `ACTION` body we have:
  * `arg0` refers to `flag`;
  * `arg0_Type` is `bool`;
  * `arg1` refers to `ptr`;
  * `arg1_Type` is `int*`;
  * `args` refers to the tuple `(flag, ptr)`;
  * `args_Type` is `std::tr1::tuple<bool, int*>`;
  * `return_Type` is `int`; and
  * `function_Type` is `int(bool, int*)`.

== Parameterized actions ==

Sometimes you'll want to parameterize the action.   For that we propose
another macro
{{{
ACTION_P(name, param) { statements; }
}}}

For example,
{{{
ACTION_P(Add, n) { return arg0 + n; }
}}}
will allow you to write
{{{
// Returns argument #0 + 5.
... WillOnce(Add(5));
}}}

For convenience, we use the term _arguments_ for the values used to
invoke the mock function, and the term _parameters_ for the values
used to instantiate an action.

Note that you don't need to provide the type of the parameter either.
Suppose the parameter is named `param`, you can also use `param_Type`
to refer to the type of the parameter as inferred by the compiler.

We will also provide `ACTION_P2`, `ACTION_P3`, and etc to support
multi-parameter actions.  For example,
{{{
ACTION_P2(ReturnDistanceTo, x, y) {
  double dx = arg0 - x;
  double dy = arg1 - y;
  return sqrt(dx*dx + dy*dy);
}
}}}
lets you write
{{{
... WillOnce(ReturnDistanceTo(5.0, 26.5));
}}}

You can view `ACTION` as a short-hand for `ACTION_P0`, and `ACTION_P` as a
short-hand for `ACTION_P1`.

== Advanced Usage ==

=== Restrict the Type of an Argument or Parameter ==

For maximum brevity and reusability, the `ACTION*` macros don't let
you specify the types of the mock function arguments and the action
parameters.  Instead, we use the types inferred by the compiler.

Sometimes, however, we may want to be more explicit about the types.
TODO: finish this.

== When to Use ==

While the new macros are very convenient, please also consider other
means for implementing actions (e.g. via `ActionInterface` or
`MakePolymorphicAction()`), especially if you need to use the defined
action a lot.  While the other approaches require more work, they give
you more control on the types of the mock function arguments and the
action parameters, which in general leads to better compiler error
messages that pay off in the long run.  They also allow overloading
actions based on parameter types, as opposed to just the number of
parameters.

== Future Improvements ==

The reason we don't allow `ACTION*()` inside a function body is that
the current C++ standard doesn't allow function-local types to be used
to instantiate templates.  The upcoming C++0x standard will lift this
restriction.  Once this is widely supported by compilers, we can
revisit this and add support for using `ACTION*()` inside a function.

= Macros for Defining Matchers =

Once the macros for defining actions are implemented, we plan to do
the same for matchers:

{{{
MATCHER(name) { statements; }
}}}

where you can refer to the value being matched as `arg`.  For example,
given:

{{{
MATCHER(IsPositive) { return arg > 0; }
}}}

you can use `IsPositive()` as a matcher that matches a value iff it is
greater than 0.

We will have `MATCHER_P`, `MATCHER_P2`, and etc as well.
